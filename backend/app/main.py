from contextlib import asynccontextmanager

from fastapi import FastAPI, Request, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse

from app.config import get_settings
from app.api.v1.router import api_router
from app.api.v1.health import router as health_router
from app.api.websocket.connector import router as ws_router
from app.core.logging import get_logger, setup_logging
from app.core.middleware import setup_middleware
from app.core.security import SecurityHeadersMiddleware, RateLimitMiddleware
from app.core.errors import TradeError
from app.core.monitoring import init_sentry


settings = get_settings()
logger = get_logger(__name__)

# Initialize Sentry monitoring
init_sentry()


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan events."""
    from apscheduler.schedulers.asyncio import AsyncIOScheduler
    from apscheduler.triggers.interval import IntervalTrigger
    
    # Startup
    setup_logging()
    logger.info(f"Starting {settings.app_name} in {settings.environment} mode")
    logger.info(f"Debug: {settings.debug}, Log Level: {settings.log_level}")
    
    # Warn about default secrets
    if settings.jwt_secret == "your-secret-key" or len(settings.jwt_secret) < 32:
        logger.warning("⚠️  JWT_SECRET not set or too short! Set a strong secret in production.")
    
    # Setup auto-trading scheduler
    scheduler = AsyncIOScheduler()
    
    try:
        from app.services.auto_trading import run_auto_trading
        
        # Run auto-trading every 15 minutes
        scheduler.add_job(
            run_auto_trading,
            trigger=IntervalTrigger(minutes=15),
            id="auto_trading",
            name="Auto Trading Scheduler",
            replace_existing=True,
        )
        scheduler.start()
        logger.info("✅ Auto-trading scheduler started (interval: 15 minutes)")
    except Exception as e:
        logger.warning(f"⚠️  Failed to start auto-trading scheduler: {e}")
    
    yield
    
    # Shutdown
    if scheduler.running:
        scheduler.shutdown()
        logger.info("Auto-trading scheduler stopped")
    logger.info(f"Shutting down {settings.app_name}")


cors_origins = settings.cors_origins()

# SECURITY: Explicitly disable API docs in production to prevent information disclosure
# API docs reveal internal structure, endpoints, schemas, and authentication methods
_docs_enabled = settings.is_development and not settings.is_production
if settings.is_production and _docs_enabled:
    raise RuntimeError("CRITICAL: API docs cannot be enabled in production (security risk)")

app = FastAPI(
    title=settings.app_name,
    version="1.0.0",
    description="AI-powered forex trading platform with ML bots and LLM supervisor",
    lifespan=lifespan,
    docs_url="/docs" if _docs_enabled else None,
    redoc_url="/redoc" if _docs_enabled else None,
    openapi_url="/openapi.json" if _docs_enabled else None,  # Also disable OpenAPI schema
)

# Setup custom middleware stack
# This must be done BEFORE CORSMiddleware so that CORS is the outermost middleware
# and can add headers even to error responses generated by inner middleware
setup_middleware(app)

# Security headers middleware
app.add_middleware(SecurityHeadersMiddleware)

# CORS middleware (must be added last to be the outermost)
app.add_middleware(
    CORSMiddleware,
    allow_origins=cors_origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# Exception handlers
@app.exception_handler(ValueError)
async def value_error_handler(request: Request, exc: ValueError):
    logger.warning(f"ValueError: {exc}")
    return JSONResponse(
        status_code=status.HTTP_400_BAD_REQUEST,
        content={"detail": str(exc)},
    )


@app.exception_handler(PermissionError)
async def permission_error_handler(request: Request, exc: PermissionError):
    logger.warning(f"PermissionError: {exc}")
    return JSONResponse(
        status_code=status.HTTP_403_FORBIDDEN,
        content={"detail": str(exc)},
    )


@app.exception_handler(TradeError)
async def trade_error_handler(request: Request, exc: TradeError):
    """Handle trading errors with proper response."""
    logger.error(f"TradeError [{exc.error_type.value}]: {exc.message}")
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={
            "detail": exc.message,
            "error_type": exc.error_type.value,
            "retryable": exc.retryable,
        },
    )


# Include routers
app.include_router(health_router, prefix="/api/v1", tags=["Health"])
app.include_router(api_router, prefix="/api/v1")
app.include_router(ws_router, prefix="/connector")

